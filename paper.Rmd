---
title: "STAT 400 Group 7 Paper DRAFT"
author: "Group7"
output: html_document
---

```{r setup, echo = FALSE}
set.seed(400)

paf_single <- function(Pe, RR) {
  AF <- (Pe * (RR - 1)) / (Pe * (RR - 1) + 1)
  return(AF)
}

var_beta_from_CI <- function(RR, Lower, Upper) {
  CIR   <- Upper / Lower
  logse <- log(CIR) / (2 * qnorm(0.975))  
  Var_beta <- logse^2                     
  return(Var_beta)
}

var_Pe <- function(Tp, Pe) {
  Var_Pe <- Pe * (1 - Pe) / Tp 
  return(Var_Pe)
}


delta_paf_ci <- function(Tp, Pe, RR, Lower, Upper){
  AF <- paf_single(Pe, RR)
  Var_Pe<- var_Pe(Tp,Pe)
  Var_beta <- var_beta_from_CI(RR, Lower, Upper) 
  
  Delta_Var_AF <- (((RR - 1)^2) * Var_Pe + ((Pe * RR)^2) *
                     Var_beta)/((1 + Pe * (RR - 1))^4)
  
  se <- sqrt(Delta_Var_AF)
  z  <- qnorm(0.975)
  
  low <- AF- (z*se)
  up  <- AF+ (z*se)
  
  out <- c(AF = AF,
           low = low,
           up  = up,
           var = Delta_Var_AF)
  return(out)
}

greenland_paf_ci <- function(Tp, Pe, RR, Lower, Upper){
  AF <- paf_single(Pe, RR)
  Var_Pe<- var_Pe(Tp,Pe)
  Var_beta <- var_beta_from_CI(RR, Lower, Upper) 
  
  O <- Pe / (1 - Pe)
  
  Green_Var_AF <- ((O / Tp) * ((RR - 1)^2 + Var_beta * RR^2)+ Var_beta * O^2 *
                     RR^2) * (1 - AF)^2 / (1 +O)^2
  
  se <- sqrt(Green_Var_AF)
  z  <- qnorm(0.975)
  
  low <- 1-(1-AF) * exp(z*se)
  up  <- 1-(1-AF) * exp(-z*se)
  
  out <- c(AF = AF,
           low = low,
           up  = up,
           var = Green_Var_AF)
  return(out)
}

mc_paf_ci <- function(Tp, Pe, RR, Lower, Upper, B= 10000){

  Var_beta <- var_beta_from_CI(RR, Lower, Upper) 
  
  beta<- log(RR)
  
  MonteRR <- rlnorm(B, meanlog = beta, sdlog = sqrt(Var_beta))
  
  MontePe <- rbinom(B, size = Tp, prob = Pe) / Tp
  
  MonteAF <- (MontePe * (MonteRR - 1)) / (1 + MontePe * (MonteRR -1))
  
  AF_est <- median(MonteAF)   
  low <- as.numeric(quantile(MonteAF, 0.025))
  up <- as.numeric(quantile(MonteAF, 0.975))
  
  out <- c(AF = AF_est,
           low = low,
           up  = up)
  return(out)
}

Tp_A <- 1000
Pe_A <- 0.10
RR_A <- 1.2
Lower_A <- 1.0524696
Upper_A <- 1.368211

true_AF_A <- paf_single(Pe_A, RR_A)

delta_A <- delta_paf_ci(Tp_A, Pe_A, RR_A, Lower_A, Upper_A)
green_A<- greenland_paf_ci(Tp_A, Pe_A, RR_A, Lower_A, Upper_A)
mc_A <- mc_paf_ci(Tp_A, Pe_A, RR_A, Lower_A, Upper_A, B = 10000)

scenarioA_results <- data.frame(
  method = c("Delta", "Greenland", "Monte Carlo"),
  AF = c(delta_A["AF"], green_A["AF"], mc_A["AF"]),
  lower = c(delta_A["low"], green_A["low"], mc_A["low"]),
  upper = c(delta_A["up"], green_A["up"], mc_A["up"])
)
Tp_B <- 100000
Pe_B <- 0.10
RR_B <- 5.0
Lower_B <- 4.3852901
Upper_B <- 5.700877

true_AF_B <- paf_single(Pe_A, RR_A)

delta_B <- delta_paf_ci(Tp_B, Pe_B, RR_B, Lower_B, Upper_B)
green_B<- greenland_paf_ci(Tp_B, Pe_B, RR_B, Lower_B, Upper_B)
mc_B <- mc_paf_ci(Tp_B, Pe_B, RR_B, Lower_B, Upper_B, B = 10000)

scenarioB_results <- data.frame(
  method = c("Delta", "Greenland", "Monte Carlo"),
  AF = c(delta_B["AF"], green_B["AF"], mc_B["AF"]),
  lower = c(delta_B["low"], green_B["low"], mc_B["low"]),
  upper = c(delta_B["up"], green_B["up"], mc_B["up"])
)

one_sim <- function() {
  Var_beta_A <- var_beta_from_CI(RR_A, Lower_A, Upper_A)
  beta_A <- log(RR_A)
  RR_star <- rlnorm(1, meanlog = beta_A, sdlog = sqrt(Var_beta_A))
  Pe_star <- rbinom(1, size = Tp_A, prob = Pe_A) / Tp_A
  d <- delta_paf_ci(Tp_A, Pe_star, RR_star, Lower_A, Upper_A)
  g <- greenland_paf_ci(Tp_A, Pe_star, RR_star, Lower_A, Upper_A)
  m <- mc_paf_ci(Tp_A, Pe_star, RR_star, Lower_A, Upper_A, B = 2000)
  
  out <- c(
    delta_low = d["low"],
    delta_up= d["up"],
    green_low = g["low"],
    green_up = g["up"],
    mc_low = m["low"],
    mc_up = m["up"]
  )
  return(out)
}

n_sim <- 500

sims <- matrix(NA, nrow =n_sim, ncol = 6)
colnames(sims) <- c("delta_low", "delta_up",
                       "green_low", "green_up",
                       "mc_low","mc_up")

for (b in 1:n_sim) {
  sims[b, ] <- one_sim()
}
sims<- as.data.frame(sims)

delta_cover <- (sims$delta_low <= true_AF_A) & (sims$delta_up>= true_AF_A)
green_cover <- (sims$green_low <= true_AF_A) & (sims$green_up>= true_AF_A)
mc_cover<- (sims$mc_low <= true_AF_A) & (sims$mc_up>= true_AF_A)

delta_width <- sims$delta_up - sims$delta_low
green_width <- sims$green_up - sims$green_low
mc_width <- sims$mc_up - sims$mc_low

coverage_width_A <- data.frame(
  method = c("Delta", "Greenland", "Monte Carlo"),
  cover  = c(mean(delta_cover),
             mean(green_cover),
             mean(mc_cover)),
  width  = c(mean(delta_width),
             mean(green_width),
             mean(mc_width))
)
sims_B <- matrix(NA, nrow = n_sim, ncol = 6)
colnames(sims_B) <- c("delta_low", "delta_up",
                       "green_low", "green_up",
                       "mc_low", "mc_up")

for (b in 1:n_sim) {
  sims_B[b, ] <- one_sim()
}

sims_B <- as.data.frame(sims_B)

delta_cover_B <- (sims_B$delta_low <= true_AF_B) & (sims_B$delta_up>= true_AF_B)
green_cover_B <- (sims_B$green_low <= true_AF_B) & (sims_B$green_up>= true_AF_B)
mc_cover_B    <- (sims_B$mc_low <= true_AF_B) & (sims_B$mc_up>= true_AF_B)

delta_width_B <- sims_B$delta_up - sims_B$delta_low
green_width_B <- sims_B$green_up - sims_B$green_low
mc_width_B    <- sims_B$mc_up - sims_B$mc_low

coverage_width_B <- data.frame(
  method = c("Delta", "Greenland", "Monte Carlo"),
  cover  = c(mean(delta_cover_B),
             mean(green_cover_B),
             mean(mc_cover_B)),
  width  = c(mean(delta_width_B),
             mean(green_width_B),
             mean(mc_width_B))
)
delta_bad <- (sims$delta_low < 0) | (sims$delta_up > 1)
green_bad <- (sims$green_low < 0) | (sims$green_up > 1)
mc_bad  <- (sims$mc_low < 0) | (sims$mc_up > 1)

boundary_A <- data.frame(
  method  = c("Delta", "Greenland", "Monte Carlo"),
  prob_outside_01 = c(mean(delta_bad),
                      mean(green_bad),
                      mean(mc_bad))
)
delta_bad_B <- (sims_B$delta_low < 0) | (sims_B$delta_up > 1)
green_bad_B <- (sims_B$green_low < 0) | (sims_B$green_up > 1)
mc_bad_B  <- (sims_B$mc_low < 0) | (sims_B$mc_up > 1)

boundary_B <- data.frame(
  method  = c("Delta", "Greenland", "Monte Carlo"),
  prob_outside_01 = c(mean(delta_bad_B),
                      mean(green_bad_B),
                      mean(mc_bad_B))
)
```

# Introduction

The population-attributable fraction (PAF) is used in epidemiology to quantify how many cases of a disease can be attributed to a specific exposure or the reduction in cases that could be achieves if the exposure were to be eliminated (https://pmc.ncbi.nlm.nih.gov/articles/PMC1508384/?page=1). PAF can be defined as: 

\[
PAF = \frac{P_e(RR-1)}{P_e(RR-1)+1}
\]

where $P_e$ is the proportion of the population that is exposed and RR is the relative risk, or the proportion of cases in the exposed over the proportion in the unexposed (https://pmc.ncbi.nlm.nih.gov/articles/PMC1508384/?page=3).

The article *A Comparison of Green, Delta, and Monte Carlo Methods to Select an Optimal Approach for Calculating the 95% Confidence Interval of the Population-Attributable Fraction.* by Lee et al. compared three methods for computing confidence intervals for PAFs: 

- Green method  
- Delta method  
- Monte Carlo method  

This project aims to replicate two of the scenarios used in the article and extend this by evaluating how often the three methods produce intervals that are outside of the logical bound of [0,1], which would indicate a proportion of the cases either less than 0% or greater than 100%.

# Methods

## Simulation Overview

We replicated the simulation design from the article *A Comparison of Green, Delta, and Monte Carlo Methods…* to estimate the Population-Attributable Fraction (PAF) and compare three confidence interval (CI) methods: the Delta method, the Greenland (Green) method, and the Monte Carlo method based on two scenarios in Lee et al. (2024):

-Scenario A: Modest effect size (RR = 1.2), moderate prevalence (Pe = 0.10), sample size Tp = 1,000.

-Scenario B: Strong effect size (RR = 5.0), same prevalence, large sample size Tp = 100,000.

Then a simulation study with $n = 500$ iterations was performed on each scenario to determine the proportion of CIs containign the true PAF, average CI width, and the the proportion of CIs that violated the [0,1] boundary.


## Notations and definitions in this study
- **PAF**: Population-attributable fraction  
- **Pe**: Prevalence of exposure in the total population  
- **RR**: Relative risk for the exposed group  
- **Tp**: Total population size  
- **V[β]**: Variance of the log(RR) estimator  
- **V[Pe]**: Variance of the exposure prevalence estimator  
- **CI**: 95% confidence interval for the PAF  

## PAF Formula
The PAF was estimated using the Levin formula, which depends on the exposure prevalence and the risk ratio:

\[
PAF = \frac{Pe(RR - 1)}{Pe(RR - 1) + 1}
\]

This formula is implemented in the function `paf_single()`.

---

## Confidence Interval Methods

### Delta Method
The Delta method uses a Taylor series approximation to estimate the variance of the PAF estimator.  
The variance of PAF is computed using the variances of Pe and β (log(RR)), following the structure:

\[
V[\widehat{PAF}] = \frac{V[Pe](RR - 1)^2 + V[β](RR \cdot Pe)^2}{(Pe(RR - 1) + 1)^4}
\]

A 95% CI is then constructed as:

\[
PAF \pm 1.96 \times \sqrt{V[\widehat{PAF}]}
\]

This procedure is implemented in `delta_paf_ci()`.



### Greenland (Green) Method
The Greenland method uses a variance-stabilizing transformation of \(1 - PAF\), incorporating the odds of exposure:

\[
O = \frac{Pe}{1 - Pe}
\]

This method accounts for variability in both the RR and Pe.  
After computing the transformed variance, the 95% CI is back-transformed to the PAF scale:

\[
CI = 1 - (1 - PAF) \exp(\pm 1.96 \sqrt{V[\widehat{PAF}]})
\]

Implemented in `greenland_paf_ci()`.



### Monte Carlo Method
The Monte Carlo method generates random samples for log(RR) and Pe:

- \( \beta = \log(RR) \) is sampled from a normal distribution with variance V[β]  
- Pe is sampled from a binomial distribution with variance V[Pe]

For each simulation, a new PAF is computed.  
The 95% CI is defined as the 2.5th and 97.5th percentiles of the simulated PAF distribution.

Implemented in `mc_paf_ci()`.



## Simulation Design

For each scenario, we:

1. Drew RR* from a log-normal distribution and Pe* from a binomial distribution.
2. Computed CIs using the three methods.
3. Recorded Ci coverage and width.
4. Calculated the proportion of CIs that had values outside of our logical boundaries.


# Results

Scenario A had a modest effect size (RR = 1.2), moderate prevalence (Pe = 0.10), sample size T_p = 1,000, and a true PAF = 0.0196
```{r}
scenarioA_results
```
```{r}
coverage_width_A
```
```{r}
boundary_A
```

```{r}
scenarioB_results
```

```{r}
coverage_width_B
```
```{r}
boundary_B
```


# Discussion

# References
ADD FOR FINAL
